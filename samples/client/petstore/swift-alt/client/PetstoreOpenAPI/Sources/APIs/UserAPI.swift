//
// UserAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class UserAPI {
    private static let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }()
    private static let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    private let transport: OpenAPITransport
    public let baseURL = URL(string: "http://petstore.swagger.io/v2")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    /**
        Create user
        - POST /user
        - This can only be done by the logged in user.
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter user: (body) Created user object 
        - returns: AnyPublisher<Void, Error> 
        */
    open func createUser(user: User) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        // Setting body parameters 
        request.httpBody = try? UserAPI.encoder.encode(user)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Creates list of users with given input array
        - POST /user/createWithArray
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter user: (body) List of user object 
        - returns: AnyPublisher<Void, Error> 
        */
    open func createUsersWithArrayInput(user: [User]) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/createWithArray"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        // Setting body parameters 
        request.httpBody = try? UserAPI.encoder.encode(user)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Creates list of users with given input array
        - POST /user/createWithList
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter user: (body) List of user object 
        - returns: AnyPublisher<Void, Error> 
        */
    open func createUsersWithListInput(user: [User]) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/createWithList"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        // Setting body parameters 
        request.httpBody = try? UserAPI.encoder.encode(user)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Delete user
        - DELETE /user/{username}
        - This can only be done by the logged in user.
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter username: (path) The name that needs to be deleted 
        - returns: AnyPublisher<Void, Error> 
        */
    open func deleteUser(username: String) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/{username}"
            .replacingOccurrences(of: "{username}", with: "\(username)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "DELETE"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Get user by user name
        - GET /user/{username}
        - parameter username: (path) The name that needs to be fetched. Use user1 for testing. 
        - returns: AnyPublisher<User, Error> 
        */
    open func getUserByName(username: String) -> AnyPublisher<User, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/{username}"
            .replacingOccurrences(of: "{username}", with: "\(username)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try UserAPI.decoder.decode(User.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Logs user into the system
        - GET /user/login
        - responseHeaders: [Set-Cookie(String), X-Rate-Limit(Int), X-Expires-After(Date)]
        - parameter username: (query) The user name for login 
        - parameter password: (query) The password for login in clear text 
        - returns: AnyPublisher<String, Error> 
        */
    open func loginUser(username: String, password: String) -> AnyPublisher<String, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/login"
        let url = baseURL.appendingPathComponent(path)
        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        components?.queryItems = [
            URLQueryItem(name: "username", value: username), 
            URLQueryItem(name: "password", value: password)
        ]
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try UserAPI.decoder.decode(String.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Logs out current logged in user session
        - GET /user/logout
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - returns: AnyPublisher<Void, Error> 
        */
    open func logoutUser() -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/logout"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Updated user
        - PUT /user/{username}
        - This can only be done by the logged in user.
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter username: (path) name that need to be deleted 
        - parameter user: (body) Updated user object 
        - returns: AnyPublisher<Void, Error> 
        */
    open func updateUser(username: String, user: User) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/user/{username}"
            .replacingOccurrences(of: "{username}", with: "\(username)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "PUT"
        
        // Setting body parameters 
        request.httpBody = try? UserAPI.encoder.encode(user)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }
}
