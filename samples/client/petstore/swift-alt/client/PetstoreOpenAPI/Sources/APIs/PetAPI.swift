//
// PetAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PetAPI {
    private static let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }()
    private static let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    private let transport: OpenAPITransport
    public let baseURL = URL(string: "http://petstore.swagger.io/v2")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    /**
        Add a new pet to the store
        - POST /pet
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter pet: (body) Pet object that needs to be added to the store 
        - returns: AnyPublisher<Pet, Error> 
        */
    open func addPet(pet: Pet) -> AnyPublisher<Pet, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        // Setting body parameters 
        request.httpBody = try? PetAPI.encoder.encode(pet)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode(Pet.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Deletes a pet
        - DELETE /pet/{petId}
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter petId: (path) Pet id to delete 
        - parameter apiKey: (header)  (optional)
        - returns: AnyPublisher<Void, Error> 
        */
    open func deletePet(petId: Int64, apiKey: String? = nil) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/{petId}"
            .replacingOccurrences(of: "{petId}", with: "\(petId)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "DELETE"
        // Setting headers
        request.allHTTPHeaderFields = [
            "api_key": apiKey
        ].compactMapValues { $0 }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        Finds Pets by status
        - GET /pet/findByStatus
        - Multiple status values can be provided with comma separated strings
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter status: (query) Status values that need to be considered for filter 
        - returns: AnyPublisher<[Pet], Error> 
        */
    open func findPetsByStatus(status: [String]) -> AnyPublisher<[Pet], Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/findByStatus"
        let url = baseURL.appendingPathComponent(path)
        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        components?.queryItems = [
            URLQueryItem(name: "status", value: status.joined(separator: ", "))
        ]
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode([Pet].self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Finds Pets by tags
        - GET /pet/findByTags
        - Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter tags: (query) Tags to filter by 
        - returns: AnyPublisher<[Pet], Error> 
        */
    open func findPetsByTags(tags: [String]) -> AnyPublisher<[Pet], Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/findByTags"
        let url = baseURL.appendingPathComponent(path)
        var components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        components?.queryItems = [
            URLQueryItem(name: "tags", value: tags.joined(separator: ", "))
        ]
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode([Pet].self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Find pet by ID
        - GET /pet/{petId}
        - Returns a single pet
        - API Key:
        - type: apiKey api_key 
        - name: api_key
        - parameter petId: (path) ID of pet to return 
        - returns: AnyPublisher<Pet, Error> 
        */
    open func getPetById(petId: Int64) -> AnyPublisher<Pet, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/{petId}"
            .replacingOccurrences(of: "{petId}", with: "\(petId)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "GET"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode(Pet.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Update an existing pet
        - PUT /pet
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter pet: (body) Pet object that needs to be added to the store 
        - returns: AnyPublisher<Pet, Error> 
        */
    open func updatePet(pet: Pet) -> AnyPublisher<Pet, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet"
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "PUT"
        
        // Setting body parameters 
        request.httpBody = try? PetAPI.encoder.encode(pet)
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode(Pet.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }

    /**
        Updates a pet in the store with form data
        - POST /pet/{petId}
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter petId: (path) ID of pet that needs to be updated 
        - parameter name: (form) Updated name of the pet (optional)
        - parameter status: (form) Updated status of the pet (optional)
        - returns: AnyPublisher<Void, Error> 
        */
    open func updatePetWithForm(petId: Int64, name: String? = nil, status: String? = nil) -> AnyPublisher<Void, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/{petId}"
            .replacingOccurrences(of: "{petId}", with: "\(petId)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                return ()
            }
            .eraseToAnyPublisher()
    }

    /**
        uploads an image
        - POST /pet/{petId}/uploadImage
        - OAuth:
        - type: oauth2
        - name: petstore_auth
        - parameter petId: (path) ID of pet to update 
        - parameter additionalMetadata: (form) Additional data to pass to server (optional)
        - parameter file: (form) file to upload (optional)
        - returns: AnyPublisher<ApiResponse, Error> 
        */
    open func uploadFile(petId: Int64, additionalMetadata: String? = nil, file: Data? = nil) -> AnyPublisher<ApiResponse, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "/pet/{petId}/uploadImage"
            .replacingOccurrences(of: "{petId}", with: "\(petId)")
        let url = baseURL.appendingPathComponent(path)
        let components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "POST"
        
        
        // Getting auth type 
        let securitySchemes: [SecurityScheme] = []
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                try PetAPI.decoder.decode(ApiResponse.self, from: response.data)
            }
            .eraseToAnyPublisher()
    }
}
