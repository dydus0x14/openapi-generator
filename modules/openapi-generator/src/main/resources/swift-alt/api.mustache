{{#operations}}//
// {{classname}}.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport

{{#description}}
/** {{{.}}} */{{/description}}
open class {{classname}} {
    private static let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }()
    private static let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    private let transport: OpenAPITransport
    public let baseURL = URL(string: "{{{basePath}}}")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }
{{#operation}}

    {{#allParams}}
    {{#isEnum}}
    /**
     * enum for parameter {{paramName}}
     */
    public enum {{{vendorExtensions.x-swift-nested-enum-type}}}: {{dataType}}, Hashable, Codable, CaseIterable {
        {{#allowableValues}}
        {{#enumVars}}
        case {{name}} = {{{value}}}
        {{/enumVars}}
        {{/allowableValues}}
    }

    {{/isEnum}}
    {{/allParams}}

    {{#vendorExtensions.x-swift-custom-error-type}}
    public enum {{{vendorExtensions.x-swift-custom-error-type}}}: Error, CustomStringConvertible {
        {{#responses}}
        {{#vendorExtensions.x-swift-has-custom-error-type}}
        // {{{message}}}
        case code{{{code}}}Error{{#dataType}}({{{dataType}}}){{/dataType}}
        {{/vendorExtensions.x-swift-has-custom-error-type}}
        {{/responses}}

        public var description: String {
            switch self {
            {{#responses}}
            {{#vendorExtensions.x-swift-has-custom-error-type}}
            case .code{{{code}}}Error{{#dataType}}(let object){{/dataType}}:
                return "{{{vendorExtensions.x-swift-custom-error-type}}}: {{{message}}}{{#dataType}}: \(object){{/dataType}}"
            {{/vendorExtensions.x-swift-has-custom-error-type}}
            {{/responses}}
            }
        }
    }
    {{/vendorExtensions.x-swift-custom-error-type}}

    /**
    {{#summary}}
        {{{.}}}
    {{/summary}}
        - {{httpMethod}} {{{path}}}{{#notes}}
        - {{{.}}}{{/notes}}{{#subresourceOperation}}
        - subresourceOperation: {{.}}{{/subresourceOperation}}{{#defaultResponse}}
        - defaultResponse: {{.}}{{/defaultResponse}}
    {{#authMethods}}
        - {{#isBasic}}BASIC{{/isBasic}}{{#isOAuth}}OAuth{{/isOAuth}}{{#isApiKey}}API Key{{/isApiKey}}:
        - type: {{type}}{{#keyParamName}} {{keyParamName}} {{#isKeyInQuery}}(QUERY){{/isKeyInQuery}}{{#isKeyInHeaer}}(HEADER){{/isKeyInHeaer}}{{/keyParamName}}
        - name: {{name}}
    {{/authMethods}}
    {{#hasResponseHeaders}}
        - responseHeaders: [{{#responseHeaders}}{{{baseName}}}({{{dataType}}}){{^-last}}, {{/-last}}{{/responseHeaders}}]
    {{/hasResponseHeaders}}
    {{#externalDocs}}
        - externalDocs: {{.}}
    {{/externalDocs}}
    {{#allParams}}
        - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
    {{/allParams}}
        - returns: AnyPublisher<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error> {{description}}
        */
    open func {{operationId}}({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{vendorExtensions.x-swift-nested-enum-type}}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{^-last}}, {{/-last}}{{/allParams}}) -> AnyPublisher<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "{{path}}"
        {{#pathParams}}
            {{! TODO: Convert param name to string if needed (can be nil, can be container) }}
            .replacingOccurrences(of: "{{=<% %>=}}{<%baseName%>}<%={{ }}=%>", with: "\({{paramName}})")
        {{/pathParams}}
        let url = baseURL.appendingPathComponent(path)
        {{#hasQueryParams}}
        // Adding query items
        var{{/hasQueryParams}}{{^hasQueryParams}}let{{/hasQueryParams}} components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        {{#hasQueryParams}}var queryItems: [URLQueryItem] = []
        {{#queryParams}}
        {{#required}}queryItems.append(URLQueryItem(name: "{{paramName}}", value: {{> toString}})){{/required}}{{^required}}if let {{paramName}} = {{paramName}} { queryItems.append(URLQueryItem(name: "{{paramName}}", value: {{> toString}})) } {{/required}}
        {{/queryParams}}
        components?.queryItems = queryItems{{/hasQueryParams}}
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "{{httpMethod}}"
        // Setting headers
        request.allHTTPHeaderFields = [{{^headerParams}}{{^hasFormParams}}
            :{{/hasFormParams}}{{/headerParams}}{{#hasFormParams}}
            "Content-Type": {{^consumes}}"multipart/form-data"{{/consumes}}{{#consumes.0}}"{{{mediaType}}}"{{/consumes.0}},{{/hasFormParams}}{{#headerParams}}
            {{! TODO: Convert value to string if needed (can be nil, can be container) }}
            "{{baseName}}": {{paramName}}{{^-last}}, {{/-last}}{{/headerParams}}
        ].compactMapValues { $0 }
        {{#hasBodyParam}}{{#bodyParam}}// Setting JSON body
        request.httpBody = try? {{classname}}.encoder.encode({{paramName}})
        if request.value(forHTTPHeaderField: "Content-Type") == nil {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        }
        {{/bodyParam}}{{/hasBodyParam}}
        {{#hasFormParams}} // Setting form encoded body
        var formEncodedItems: [String] = []
        {{#formParams}}
        {{#required}}formEncodedItems.append("{{paramName}}=\({{> toString}})"){{/required}}{{^required}}if let {{paramName}} = {{paramName}} { formEncodedItems.append("{{paramName}}=\({{> toString}})") } {{/required}}
        {{/formParams}}
        request.httpBody = formEncodedItems.joined(separator: "&").data(using: .utf8)
        {{/hasFormParams}}
        // Getting auth type {{! TODO: Set proper auth type) }}
        let securitySchemes: [SecurityScheme] = [{{#authMethods}}{{#isBasicBearer}}.bearer{{/isBasicBearer}}{{/authMethods}}]
        return transport.send(request: request, securitySchemes: securitySchemes)
        {{#vendorExtensions.x-swift-custom-error-type}}
            .mapError { transportError -> Error in 
                {{#responses}}
                {{#vendorExtensions.x-swift-has-custom-error-type}}
                if transportError.statusCode == {{{code}}} {
                    {{#dataType}}
                    do {
                        let error = try {{classname}}.decoder.decode({{{dataType}}}.self, from: transportError.data)
                        return {{{vendorExtensions.x-swift-custom-error-type}}}.code{{{code}}}Error(error)
                    } catch {
                        return error
                    }
                    {{/dataType}}
                    {{^dataType}}
                    return {{{vendorExtensions.x-swift-custom-error-type}}}.code{{{code}}}Error
                    {{/dataType}}
                }
                {{/vendorExtensions.x-swift-has-custom-error-type}}
                {{/responses}}
                return transportError
            }
        {{/vendorExtensions.x-swift-custom-error-type}}
            .tryMap { response in
                {{! TODO: Check responses properly }}
                {{#returnType}}
                {{#vendorExtensions.x-swift-is-not-codable}}
                if let object = try JSONSerialization.jsonObject(with: response.data, options: []) as? {{{returnType}}} {
                    return object
                } else {
                    throw OpenAPITransportError.invalidResponseMappingError(data: response.data)
                }
                {{/vendorExtensions.x-swift-is-not-codable}} 
                {{^vendorExtensions.x-swift-is-not-codable}} 
                try {{classname}}.decoder.decode({{{returnType}}}.self, from: response.data)
                {{/vendorExtensions.x-swift-is-not-codable}} 
                {{/returnType}}
                {{^returnType}}
                return ()
                {{/returnType}}
            }
            .eraseToAnyPublisher()
    }
{{/operation}}
}
{{/operations}}