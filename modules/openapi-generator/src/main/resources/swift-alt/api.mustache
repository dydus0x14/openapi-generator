{{#operations}}//
// {{classname}}.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
// Run in root folder to build example mvn clean package -DskipTests; ./bin/generate-samples.sh bin/configs/swift-alt-petstore-new.yaml

import Foundation
import Combine
// import Runtime

{{#description}}
/** {{{.}}} */{{/description}}
open class {{classname}} {
    private let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }()
    private let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    private let transport: Transport

    public init(_ transport: Transport) {
        self.transport = transport
    }
{{#operation}}

    /**
    {{#summary}}
        {{{.}}}
    {{/summary}}
        - {{httpMethod}} {{{path}}}{{#notes}}
        - {{{.}}}{{/notes}}{{#subresourceOperation}}
        - subresourceOperation: {{.}}{{/subresourceOperation}}{{#defaultResponse}}
        - defaultResponse: {{.}}{{/defaultResponse}}
    {{#authMethods}}
        - {{#isBasic}}BASIC{{/isBasic}}{{#isOAuth}}OAuth{{/isOAuth}}{{#isApiKey}}API Key{{/isApiKey}}:
        - type: {{type}}{{#keyParamName}} {{keyParamName}} {{#isKeyInQuery}}(QUERY){{/isKeyInQuery}}{{#isKeyInHeaer}}(HEADER){{/isKeyInHeaer}}{{/keyParamName}}
        - name: {{name}}
    {{/authMethods}}
    {{#hasResponseHeaders}}
        - responseHeaders: [{{#responseHeaders}}{{{baseName}}}({{{dataType}}}){{^-last}}, {{/-last}}{{/responseHeaders}}]
    {{/hasResponseHeaders}}
    {{#externalDocs}}
        - externalDocs: {{.}}
    {{/externalDocs}}
    {{#allParams}}
        - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
    {{/allParams}}
        - returns: AnyPublisher<Result<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error>, Never> {{description}}
        */
    open func {{operationId}}({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{datatypeWithEnum}}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{^-last}}, {{/-last}}{{/allParams}}) -> AnyPublisher<Result<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error>, Never> {
        // Creating final URL with query items and path
        var components = URLComponents()
        components.path = "{{path}}"
        {{#pathParams}}
            {{! TODO: Convert param name to string if needed (can be nil, can be container) }}
            .replacingOccurrences(of: "{{=<% %>=}}{<%baseName%>}<%={{ }}=%>", with: "\({{paramName}})")
        {{/pathParams}}
        {{#hasQueryParams}}components.queryItems = [
            {{#queryParams}}
            {{! TODO: Convert value to string if needed (can be nil, can be container) }}
            URLQueryItem(name: "{{paramName}}", value: {{#isArray}}{{paramName}}{{^required}}?{{/required}}.joined(separator: ", "){{/isArray}}{{^isArray}}{{paramName}}{{/isArray}}){{^-last}}, {{/-last}}
            {{/queryParams}}
        ]{{/hasQueryParams}}
        guard let url = components.url(relativeTo: transport.baseURL) else {
            {{! TODO: Process error correctly }}
            fatalError("URL is nil")
        }

        var request = URLRequest(url: url)
        request.httpMethod = "{{httpMethod}}"
        {{#hasHeaderParams}}// Setting headers
        request.allHTTPHeaderFields = [{{^headerParams}}{{^hasFormParams}}
            :{{/hasFormParams}}{{/headerParams}}{{#hasFormParams}}
            "Content-Type": {{^consumes}}"multipart/form-data"{{/consumes}}{{#consumes.0}}"{{{mediaType}}}"{{/consumes.0}},{{/hasFormParams}}{{#headerParams}}
            {{! TODO: Convert value to string if needed (can be nil, can be container) }}
            "{{baseName}}": {{paramName}}{{^-last}}, {{/-last}}{{/headerParams}}
        ].compactMapValues { $0 }{{/hasHeaderParams}}
        {{#hasBodyParam}}{{#bodyParam}}// Setting body parameters {{! TODO: Convert value to data if needed (can be nil, can be Data already) }}
        request.httpBody = try? encoder.encode({{paramName}}){{/bodyParam}}{{/hasBodyParam}}
        // Getting auth type {{! TODO: Set proper auth type) }}
        let securityScheme: SecurityScheme = .none
        return transport.send(request: request, securityScheme: securityScheme)
            .map { response -> Result<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error> in
                {{! TODO: Check responses properly }}
                if response.response?.statusCode == 200 {
                    {{#returnType}}
                    if let data = response.data {
                        return Result { try self.decoder.decode({{{returnType}}}.self, from: data) }
                    } else {
                        return .failure(TransportError.unknown)
                    }
                    {{/returnType}}
                    {{^returnType}}
                    return .success(())
                    {{/returnType}}
                } else {
                    return .failure(response.error ?? TransportError.unknown)
                }
            }
            .eraseToAnyPublisher()
    }
{{/operation}}
}
{{/operations}}


private class OpenISO8601DateFormatter: DateFormatter {
    static let withoutSeconds: DateFormatter = {
        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssZZZZZ"
        return formatter
    }()

    private func setup() {
        calendar = Calendar(identifier: .iso8601)
        locale = Locale(identifier: "en_US_POSIX")
        timeZone = TimeZone(secondsFromGMT: 0)
        dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"
    }

    override init() {
        super.init()
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    override func date(from string: String) -> Date? {
        if let result = super.date(from: string) {
            return result
        }
        return OpenISO8601DateFormatter.withoutSeconds.date(from: string)
    }
}