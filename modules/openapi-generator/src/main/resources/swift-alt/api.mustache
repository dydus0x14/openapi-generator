{{#operations}}//
// {{classname}}.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport

{{#description}}
/** {{{.}}} */{{/description}}
open class {{classname}} {
    private static let encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        encoder.outputFormatting = .prettyPrinted
        return encoder
    }()
    private static let decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    private let transport: OpenAPITransport
    public let baseURL = URL(string: "{{{basePath}}}")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }
{{#operation}}

    {{#allParams}}
    {{#isEnum}}
    /**
     * enum for parameter {{paramName}}
     */
    public enum {{enumName}}_{{operationId}}: {{dataType}}, Hashable, Codable, CaseIterable {
        {{#allowableValues}}
        {{#enumVars}}
        case {{name}} = {{{value}}}
        {{/enumVars}}
        {{/allowableValues}}
    }

    {{/isEnum}}
    {{/allParams}}

    /**
    {{#summary}}
        {{{.}}}
    {{/summary}}
        - {{httpMethod}} {{{path}}}{{#notes}}
        - {{{.}}}{{/notes}}{{#subresourceOperation}}
        - subresourceOperation: {{.}}{{/subresourceOperation}}{{#defaultResponse}}
        - defaultResponse: {{.}}{{/defaultResponse}}
    {{#authMethods}}
        - {{#isBasic}}BASIC{{/isBasic}}{{#isOAuth}}OAuth{{/isOAuth}}{{#isApiKey}}API Key{{/isApiKey}}:
        - type: {{type}}{{#keyParamName}} {{keyParamName}} {{#isKeyInQuery}}(QUERY){{/isKeyInQuery}}{{#isKeyInHeaer}}(HEADER){{/isKeyInHeaer}}{{/keyParamName}}
        - name: {{name}}
    {{/authMethods}}
    {{#hasResponseHeaders}}
        - responseHeaders: [{{#responseHeaders}}{{{baseName}}}({{{dataType}}}){{^-last}}, {{/-last}}{{/responseHeaders}}]
    {{/hasResponseHeaders}}
    {{#externalDocs}}
        - externalDocs: {{.}}
    {{/externalDocs}}
    {{#allParams}}
        - parameter {{paramName}}: ({{#isFormParam}}form{{/isFormParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isPathParam}}path{{/isPathParam}}{{#isHeaderParam}}header{{/isHeaderParam}}{{#isBodyParam}}body{{/isBodyParam}}) {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
    {{/allParams}}
        - returns: AnyPublisher<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error> {{description}}
        */
    open func {{operationId}}({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{datatypeWithEnum}}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{^-last}}, {{/-last}}{{/allParams}}) -> AnyPublisher<{{{returnType}}}{{^returnType}}Void{{/returnType}}, Error> {
        // Creating final URL with query items and path
        guard let baseURL = transport.baseURL ?? self.baseURL else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        let path = "{{path}}"
        {{#pathParams}}
            {{! TODO: Convert param name to string if needed (can be nil, can be container) }}
            .replacingOccurrences(of: "{{=<% %>=}}{<%baseName%>}<%={{ }}=%>", with: "\({{paramName}})")
        {{/pathParams}}
        let url = baseURL.appendingPathComponent(path)
        {{#hasQueryParams}}
        // Adding query items
        var{{/hasQueryParams}}{{^hasQueryParams}}let{{/hasQueryParams}} components = URLComponents(url: url, resolvingAgainstBaseURL: false)
        {{#hasQueryParams}}var queryItems: [URLQueryItem] = []
        {{#queryParams}}
        {{#required}}queryItems.append(URLQueryItem(name: "{{paramName}}", value: {{> toString}})){{/required}}{{^required}}if let {{paramName}} = {{paramName}} { queryItems.append(URLQueryItem(name: "{{paramName}}", value: {{> toString}})) } {{/required}}
        {{/queryParams}}
        components?.queryItems = queryItems{{/hasQueryParams}}
        guard let requestURL = components?.url else {
            return Fail(error: OpenAPITransportError.badURLError())
                .eraseToAnyPublisher()
        }

        var request = URLRequest(url: requestURL)
        request.httpMethod = "{{httpMethod}}"
        // Setting headers
        request.allHTTPHeaderFields = [{{^headerParams}}{{^hasFormParams}}
            :{{/hasFormParams}}{{/headerParams}}{{#hasFormParams}}
            "Content-Type": {{^consumes}}"multipart/form-data"{{/consumes}}{{#consumes.0}}"{{{mediaType}}}"{{/consumes.0}},{{/hasFormParams}}{{#headerParams}}
            {{! TODO: Convert value to string if needed (can be nil, can be container) }}
            "{{baseName}}": {{paramName}}{{^-last}}, {{/-last}}{{/headerParams}}
        ].compactMapValues { $0 }
        {{#hasBodyParam}}{{#bodyParam}}// Setting JSON body
        request.httpBody = try? {{classname}}.encoder.encode({{paramName}})
        {{/bodyParam}}{{/hasBodyParam}}
        {{#hasFormParams}} // Setting form encoded body
        var formEncodedItems: [String] = []
        {{#formParams}}
        {{#required}}formEncodedItems.append("{{paramName}}=\({{> toString}})"){{/required}}{{^required}}if let {{paramName}} = {{paramName}} { formEncodedItems.append("{{paramName}}=\({{> toString}})") } {{/required}}
        {{/formParams}}
        request.httpBody = formEncodedItems.joined(separator: "&").data(using: .utf8)
        {{/hasFormParams}}
        // Getting auth type {{! TODO: Set proper auth type) }}
        let securitySchemes: [SecurityScheme] = [{{#authMethods}}{{#isBasicBearer}}.bearer{{/isBasicBearer}}{{/authMethods}}]
        return transport.send(request: request, securitySchemes: securitySchemes)
            .tryMap { response in
                {{! TODO: Check responses properly }}
                {{#returnType}}
                {{#vendorExtensions.x-swift-isNotCodable}}
                if let object = try JSONSerialization.jsonObject(with: response.data, options: []) as? {{{returnType}}} {
                    return object
                } else {
                    throw OpenAPITransportError.invalidResponseMappingError(data: response.data)
                }
                {{/vendorExtensions.x-swift-isNotCodable}} 
                {{^vendorExtensions.x-swift-isNotCodable}} 
                try {{classname}}.decoder.decode({{{returnType}}}.self, from: response.data)
                {{/vendorExtensions.x-swift-isNotCodable}} 
                {{/returnType}}
                {{^returnType}}
                return ()
                {{/returnType}}
            }
            .eraseToAnyPublisher()
    }
{{/operation}}
}
{{/operations}}